extern crate phf_codegen;
extern crate syn;
extern crate walkdir;

use ristretto_classfile::{
    JAVA_8, JAVA_11, JAVA_17, JAVA_21, JAVA_24, Version, VersionSpecification,
};
use std::collections::HashMap;
use std::env;
use std::error::Error;
use std::fs::File;
use std::io::{Read, Write};
use std::ops::Deref;
use std::path::{Path, PathBuf};
use syn::parse::{Parse, ParseStream};
use syn::{Expr, ExprCall, Item, LitStr, Result as SynResult};
use walkdir::WalkDir;

/// The supported Java versions for intrinsic methods.
///
/// This array contains tuples of version names and their corresponding `Version` objects. Be sure
/// to update this list as well as the `parse_java_version` function if new Java versions are added.
const JAVA_VERSIONS: [(&str, &Version); 5] = [
    ("JAVA_8", &JAVA_8),
    ("JAVA_11", &JAVA_11),
    ("JAVA_17", &JAVA_17),
    ("JAVA_21", &JAVA_21),
    ("JAVA_24", &JAVA_24),
];

/// Returns the Java version based on the provided version string.
fn parse_java_version(version: &str) -> Version {
    match version {
        "JAVA_8" => JAVA_8,
        "JAVA_11" => JAVA_11,
        "JAVA_17" => JAVA_17,
        "JAVA_21" => JAVA_21,
        "JAVA_24" => JAVA_24,
        _ => panic!("Unsupported intrinsic method Java version: {version}"),
    }
}

const RUST_KEYWORDS: [&str; 3] = ["impl", "ref", "unsafe"];

/// Builds the intrinsics map and generates the intrinsics.rs file.
///
/// This function iterates over all .rs files in the "src" directory, processes each file to find
/// intrinsic definitions, and then generates a map of intrinsic signatures to function pointers.
pub fn build() -> Result<(), Box<dyn Error>> {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")?;
    let source_path = Path::new(&manifest_dir).join("src");
    let destination_path = Path::new(&source_path)
        .join("intrinsic_methods")
        .join("intrinsics.rs");

    let intrinsic_methods = get_intrinsic_methods(source_path)?;

    let mut file = File::create(&destination_path)?;
    writeln!(
        &mut file,
        "//! This file is automatically generated by build.rs. Do not edit manually."
    )?;
    writeln!(&mut file, "use crate::intrinsic_methods::IntrinsicMethod;")?;

    for (version_name, version) in JAVA_VERSIONS {
        write_intrinsic_method_map(&mut file, version_name, version, &intrinsic_methods)?;
    }
    println!("cargo:rerun-if-changed=src");
    Ok(())
}

/// Retrieves intrinsic methods from the source path.
fn get_intrinsic_methods(
    source_path: PathBuf,
) -> Result<HashMap<String, (String, VersionSpecification)>, Box<dyn Error>> {
    let mut intrinsic_methods = HashMap::new();
    for entry in WalkDir::new(source_path.clone()) // Or use src_dir if absolute path is preferred
        .into_iter()
        .filter_map(|entry| entry.ok())
    {
        process_file_entry(&source_path, entry, &mut intrinsic_methods)?;
    }
    Ok(intrinsic_methods)
}

/// Processes a single directory entry.
///
/// If the entry is a Rust file, it reads the file content, parses it, and processes its items to
/// find intrinsic definitions.
fn process_file_entry(
    source_path: &PathBuf,
    entry: walkdir::DirEntry,
    intrinsic_methods: &mut HashMap<String, (String, VersionSpecification)>,
) -> Result<(), Box<dyn Error>> {
    let file_name = entry.file_name().to_string_lossy();
    if !file_name.ends_with(".rs") {
        return Ok(());
    }
    // Get the relative path to the source directory without the file name.
    let relative_path = entry
        .path()
        .strip_prefix(source_path)
        .unwrap_or(entry.path());
    let mut module = relative_path.to_string_lossy().to_string();
    module = module
        .strip_suffix("/mod.rs")
        .unwrap_or(&module)
        .to_string();
    module = module
        .strip_suffix("\\mod.rs")
        .unwrap_or(&module)
        .to_string();
    module = module.strip_suffix(".rs").unwrap_or(&module).to_string();
    module = module.replace(['/', '\\'], "::");
    for keyword in RUST_KEYWORDS {
        // Replace Rust keywords with a prefixed version to avoid conflicts.  This replacement is
        // necessary because Rust keywords are used in Java package names.  The approach to
        // replacement is overly simplistic (will replace "reflect" with "r#reflect"), but it should
        // be sufficient for the current use case.
        module = module.replace(&format!("::{keyword}"), &format!("::r#{keyword}"));
    }
    module = format!("crate::{module}");

    let mut file_content = String::new();
    let mut file = File::open(entry.path())?;
    file.read_to_string(&mut file_content)?;

    if let Ok(syn_file) = syn::parse_file(&file_content) {
        for item in syn_file.items {
            process_item(&module, item, intrinsic_methods);
        }
    }
    Ok(())
}

/// Helper struct for parsing macro attributes
struct IntrinsicMethodArgs {
    signature: LitStr,
    version_specification: Expr,
}

impl Parse for IntrinsicMethodArgs {
    fn parse(input: ParseStream) -> SynResult<Self> {
        let signature: LitStr = input.parse()?;
        input.parse::<syn::Token![,]>()?;
        let version_spec: Expr = input.parse()?;
        Ok(IntrinsicMethodArgs {
            signature,
            version_specification: version_spec,
        })
    }
}

/// Processes a syn::Item to find intrinsic method definitions.
fn process_item(
    module: &str,
    item: Item,
    intrinsic_methods: &mut HashMap<String, (String, VersionSpecification)>,
) {
    if let Item::Fn(ref function) = item {
        let attribute = function
            .attrs
            .iter()
            .find(|attribute| attribute.path().is_ident("intrinsic_method"));
        if let Some(attribute) = attribute {
            let arguments = attribute.parse_args::<IntrinsicMethodArgs>().unwrap();
            let function_name = format!("{module}::{}", function.sig.ident);
            let signature = arguments.signature.value();
            let version_specification = version_specification(&arguments.version_specification);
            intrinsic_methods.insert(signature, (function_name, version_specification));
        }
    }
}

/// Parses the version specification expression into a VersionSpecification.
fn version_specification(expression: &Expr) -> VersionSpecification {
    if let Expr::Path(path) = expression {
        if path.path.is_ident("Any") {
            return VersionSpecification::Any;
        } else {
            panic!(
                "Unsupported version specification in intrinsic method attribute: {:?}",
                path.path.get_ident(),
            );
        }
    }

    let Expr::Call(call) = expression else {
        panic!(
            "[call] Unsupported version specification in intrinsic method attribute: {expression:?}"
        );
    };
    let Expr::Path(function) = call.func.deref() else {
        panic!(
            "[call.path] Unsupported version specification in intrinsic method attribute: {expression:?}"
        );
    };
    let Some(specification_type) = function.path.get_ident() else {
        panic!(
            "[call.path.ident] Unsupported version specification in intrinsic method attribute: {expression:?}"
        );
    };
    let specification_type = specification_type.to_string();
    if specification_type == "In" {
        let versions = java_version_vec(call);
        // Leak the Vec to avoid lifetime issues with the VersionSpecification::In variant
        return VersionSpecification::In(versions.leak());
    }

    let version = java_version(call.args.first());
    match specification_type.as_str() {
        "Equal" => VersionSpecification::Equal(version),
        "NotEqual" => VersionSpecification::NotEqual(version),
        "LessThan" => VersionSpecification::LessThan(version),
        "LessThanOrEqual" => VersionSpecification::LessThanOrEqual(version),
        "GreaterThan" => VersionSpecification::GreaterThan(version),
        "GreaterThanOrEqual" => VersionSpecification::GreaterThanOrEqual(version),
        "Between" => {
            let end_version = java_version(call.args.get(1));
            VersionSpecification::Between(version, end_version)
        }
        _ => panic!(
            "Unsupported version specification in intrinsic method attribute \"{specification_type}\": {call:?}"
        ),
    }
}

/// Parses the Java versions from a call expression containing `&[version_1, version_2]`
fn java_version_vec(call: &ExprCall) -> Vec<Version> {
    let Some(Expr::Reference(reference_expr)) = call.args.first() else {
        panic!("(call.args[0]]) Unsupported expression in call: {call:?}");
    };
    let Expr::Array(array) = reference_expr.expr.deref() else {
        panic!("(call.args[0].expr) Unsupported expression in call: {call:?}");
    };
    let mut versions = Vec::new();
    for element in &array.elems {
        let Expr::Path(version_path) = element else {
            continue;
        };
        if let Some(segment) = version_path.path.segments.first() {
            let version = segment.ident.to_string();
            versions.push(parse_java_version(&version));
        }
    }
    versions
}
/// Returns the Java version based on the provided expression.
fn java_version(expression: Option<&Expr>) -> Version {
    if let Some(Expr::Path(path)) = expression {
        if let Some(segment) = path.path.segments.first() {
            let version = segment.ident.to_string();
            return parse_java_version(&version);
        }
    }
    panic!("Unsupported Java version in intrinsic method attribute: {expression:?}");
}

/// Writes the intrinsic method map for the specified version to the specified file.
fn write_intrinsic_method_map(
    file: &mut File,
    version_name: &str,
    version: &Version,
    intrinsic_methods: &HashMap<String, (String, VersionSpecification)>,
) -> Result<(), Box<dyn Error>> {
    let mut map_builder = phf_codegen::Map::<&str>::new();

    for (signature, (function, version_specification)) in intrinsic_methods {
        if !version_specification.matches(version) {
            continue;
        }
        let function = format!("{function} as IntrinsicMethod");
        map_builder.entry(signature, function);
    }
    writeln!(file)?;
    writeln!(file, "#[expect(clippy::unreadable_literal)]")?;
    let intrinsic_method_signature = "IntrinsicMethod";
    writeln!(
        file,
        "pub(crate) static {version_name}: phf::Map<&'static str, {intrinsic_method_signature}> = {};",
        map_builder.build()
    )?;
    Ok(())
}
